/*Problem Statement: Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

There is only one duplicate number in nums, return this duplicate number.

Follow-ups:

How can we prove that at least one duplicate number must exist in nums? 
Can you solve the problem without modifying the array nums?
Can you solve the problem using only constant, O(1) extra space?
Can you solve the problem with runtime complexity less than O(n2)?
 

Example 1:

Input: nums = [1,3,4,2,2]
Output: 2
Example 2:

Input: nums = [3,1,3,4,2]
Output: 3
Example 3:

Input: nums = [1,1]
Output: 1
Example 4:

Input: nums = [1,1,2]
Output: 1
 

Constraints:

2 <= n <= 3 * 104
nums.length == n + 1
1 <= nums[i] <= n
All the integers in nums appear only once except for precisely one integer which appears two or more times.*/



/*Solution 1: by sorting the array and comparing if the adjacent elements are equal
              T.C: O(nlogn)
              S.C: O(1)*/
              class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int n=nums.size();
        int res;
        //sorting the array
        sort(nums.begin(),nums.end());
        for(int i=0; i<n; i++){
            if(nums[i]==nums[i+1]){
                res=nums[i];
                return res;
            }
        }
        return -1;
    }
};


/*Solution 2: using an extra array(using the elements of given array as indices for the extra array) and marking the indices one by one to 0 or a negative number, the duplicate
              number index will already be marked and we can return the duplicate number
              T.C: O(n)
              S.C: O(n)*/
              class Solution {
public:
   int findDuplicate(vector<int>& nums) {
       int n=nums.size();
       int res;
       //initializing the vector elements to 1
       vector<int> count(n,1);
       for(int i=0; i<n; i++){
           if(count[nums[i]]==1)
               count[nums[i]]=0; //marking the elements of given array
           //if already marked
           else{
               res=nums[i];
               return res;
           }
       }
       return -1
   }
};



/*Solution 3: optimizing the above code in terms of S.C i.e marking in the same array
              T.C: O(n)
              S.c: O(1)*/
 
/*Ex: nums[]={1,3,2,2,4}
      1st iteration-> temp=abs(nums[0])-> temp=abs(1)->temp=1
                      nums[temp]=nums[1]=3
                      3 is +ve so, replace 3 by its -ve value
                      now nums[]= 1,-3,2,2,4
      2nd iteration-> temp=abs(nums[1])-> temp=abs(-3)->temp=3
                      nums[temp]=nums[3]=2
                      2 is +ve so, replace 2 by its -ve value
                      now nums[]= 1,-3,2,-2,4
      3rd iteration-> temp=abs(nums[2])-> temp=abs(2)->temp=2
                      nums[temp]=nums[2]=2
                      2 is +ve so, replace 2 by its -ve value
                      now nums[]= 1,-3,-2,-2,4
      4rth iteration-> temp=abs(nums[3])-> temp=abs(-2)->temp=2
                      nums[temp]=nums[2]=-2
                      3 is -ve so, 
                      return temp*/
                      
class Solution {
public:
   int findDuplicate(vector<int>& nums) {
       int n=nums.size();
       int res;
       for(int i=0; i<n; i++){
           int temp=abs(nums[i]);
           if(nums[temp]>0)
               nums[temp]= -nums[temp];
           else
               return temp;
       }
       return -1;
   }
};



/*Solution 4: tortoise and hare approach
